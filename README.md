# Задание 1

## Уровень 1. Проектирование
Данных по проекту Mesto и его планам недостаточно, чтобы принять правильное решение относительно технологий. Поэтому будем считать, что требуется сделать POC приложения, используя разбивку на микросервисы. 
Для простоты будем использовать React во всех микросервисах. Поэтому нет особой нужны в SPA, воспользуемся конфигурацией Webpack Module Federation.

## Уровень 2. Планирование изменений
У нас нет информации о составе команды Mesto, а также нет строгих требований по изоляции микросервисов. Поэтому идеальным вариантом будет разбивка по бизнес функциям, то есть вертикальная нарезка.

### Сервисы:
- Сервис авторизации: форма логина и регистрации/
- Сервис карточек: страница с фото карточками с функциями удаления, добавления и лайков.
- Сервис профиля пользователя: форма профиля с функциями редактирования имени и аватарки пользователя.
- Хост приложения.

### Управление состоянием
- Для простоты в данном POC использовалась модель событийная модель Pub/Sub. Однако более правильным решением будет использование глобального состояния, в данном случае библиотеки Redux. В данном приложении все микросервисы тесно связаны, поэтому использование глобальных значений более оптимально. Например, во всех сервисах необходимо использовать значение (email, token) текущего пользователя.

### Структура
microfrontend
 - auth
 	- blocks (styles)
 	- components
 		- login.js
 		- register.js
 	- utils
 		- auth-api.js
 	- webpack.config.js
 	- package.json
 - profile
  	- blocks (styles)
 	- components
 		- editAvatarPopup.js
 		- editProfilePopup.js
 		- profile.js
 	- utils
 		- api.js
 	- webpack.config.js
 	- package.json
 - photos
  	- blocks (styles)
 	- components
 		- addPlacePopup.js
 		- imagePopup.js
 		- card.js
 		- cards.js
 	- utils
 		- api.js
 	- webpack.config.js
 	- package.json
 - host
  	- blocks (styles)
 	- components
 		- App.js
 		- footer.js
 		- header.js
 		- infoTooltip.js
 		- main.js
 		- protectedRoute.js
 	- images
 	- webpack.config.js
 	- package.json 	

### Дополнительные сервисы на будущее:
- Сервис общих контролов и утилит: кастомные контролы общие для всех микросервисов или общие утилиты. Например, базовый контрол для всплывающего окна, а также контрол Header, Footer.
- Сервис лайков: на сайте напрашивается раздел с видео контентом, где также понадобится функционал лайков, который можно будет вынести в отдельный сервис.

## Уровень 3. Запуск готового кода
Запуск приложения Mesto:
- cd frontend/microfrontend/host && npm start:all
```
"start:all": "concurrently \"cd ../auth && npm install && npm start\" \"cd ../photos && npm install && npm start\" \"cd ../profile && npm install && npm start\" \"cd ../host && npm install && npm start\""
```

# Задание 2

Схема draw.io c новой микросервисной архитектурой: [microservice_architecture_task2.drawio](microservice_architecture_task2.drawio)

##  Проектирование и планирование изменений
У нас нет информации о составе команды монолитного приложения, а также нет строгих требований по изоляции микросервисов. Поэтому идеальным вариантом будет разбивка по бизнес функциям, то есть вертикальная нарезка.

### Сервисы
- Сервис авторизации
- Сервис профиля пользователя
- Сервис платежей
- Сервис поддержки
- Сервис услуг, товаров
- Сервис заказов
- Сервис аукционов и аппелляций
- Сервис аналитики
- Сервис уведомлений

### Детали реализации сервисов
#### Маршрутизация 
В качестве простого решения можно использовать обратный Proxy Server. На период миграции от монолита к микросервисам, маршрутизатор может отправлять некоторые запросы на монолит через слой ACL, который будет инкапсулировать старую систему.

#### Авторизация
В зависимости от роли (простой пользователь, модератор, админ) пользователь получит разные привилегии и возможности. Отдельная страница администратора не предусмотрена, но может быть добавлена в будущем. Для удобства часть данных при авторизации можно хранить в кэше, например, для активных пользователей хранить токен сессии и ID пользователя.

#### Бэкенд
По начальной схеме сложно оценить бэкенд монолита, поэтому слой Backend for Frontend можно пропустить. Для более точной схемы нужно оценить исходный код монолита.

#### Аналитика и уведомления
Для крупных проектов, где требуется аналитика, обычной СУБД будет недостаточно. Необходимо записывать отдельные события исходя из бизнес требований. Для таких целей можно использовать специальную систему, например Apache Kafka. В нашем случае, сервисы аукционов, заказов, товаров и услуг помимо своих собственных БД будут также записывать определенные события в Kafka. Например, какой аукцион состоялся, сколько было участников, в какое время. Какие товары и услуги чаще всего ищут в поисковой строке и т.д. Эти события записываются в Kafka, далее на основе этих данных сервис аналитики может строить отчеты, а сервис уведомлений может рассылать push-уведомления клиентов нашего портала.
